# ---------------------------------------------------------------------------
# ProcRoads_Enviva.py
# Version:  ArcGIS 10.3.1 / Python 2.7.8
# Creator: Kirsten R. Hazler
# Creation Date: 2019-04-26
# Last Edit: 2019-04-29

# Summary:
# Creates road surfaces from TIGER roads centerlines. Developed specifically for Enviva project.

# Usage tips:
# See https://www2.census.gov/geo/pdfs/reference/mtfccs2018.pdf for MTFCC code definitions
# See https://www.census.gov/library/reference/code-lists/route-type-codes.html for RTTYP code definitions
# ---------------------------------------------------------------------------

# Import Helper module and functions
import Helper
from Helper import *

def FilterAndProject(inDir, inRoadsGDB):
   '''For all shapefiles in the input directory, filters out the irrelevant road segments, then projects to the CONUS coordinate system, storing output in the designated output geodatabase. 
   Parameters:
   - inDir: Input directory containing TIGER roads shapefiles to be processed.
   - inRoadsGDB: Geodatabase designated for storing output projected feature classes. (This must already exist; it is not created on the fly. It should not contain any other data.)
   Assumptions:
   - All shapefiles in designated input directory are standard TIGER roads data, in NAD 1983 geographic coordinate system.
   - All shapefiles in designated input directory are intended to be processed. 
   '''
   
   # Get list of shapefiles to process
   arcpy.env.workspace = inDir
   inRoads = arcpy.ListFeatureClasses()
   
   # Set up failure list
   failList = []
   
   # For each shapefile in list:
   for roads in inRoads:
      try:
         name = os.path.basename(roads)
         printMsg('Shapefile name is %s'%name)
         geoid = name[8:13]
         roads_filt = "in_memory" + os.sep + "roads_filt_%s" %geoid
         roads_prj = inRoadsGDB + os.sep + "roads_conus_%s" %geoid
         
         printMsg('Working on GEOID %s...'%geoid)
         
         # Filter out irrelevant segments that should not be buffered
         # Excludes the following MTFCC types:
         # - S1730: Alleys
         # - S1780: Parking Lot Roads
         # - S9999: Driveways
         # - S1710: Walkways/Pedestrian Trails
         # - S1720: Stairways
         # - S1740: Service Vehicle Private Drives
         # - S1820: Bike Paths or Trails
         # - S1830: Bridle Paths
         # - S1500: 4WD Vehicular Trails
         qry = "MTFCC NOT IN ( 'S1730', 'S1780', 'S9999', 'S1710', 'S1720', 'S1740', 'S1820', 'S1830', 'S1500' )"
         printMsg('Filtering out irrelevant road segments...')
         arcpy.Select_analysis (roads, roads_filt, qry)
         printMsg('Roads filtered.')
         
         # Project to CONUS
         cs = "PROJCS['USA_Contiguous_Albers_Equal_Area_Conic_USGS_version',GEOGCS['GCS_North_American_1983',DATUM['D_North_American_1983',SPHEROID['GRS_1980',6378137.0,298.257222101]],PRIMEM['Greenwich',0.0],UNIT['Degree',0.0174532925199433]],PROJECTION['Albers'],PARAMETER['False_Easting',0.0],PARAMETER['False_Northing',0.0],PARAMETER['central_meridian',-96.0],PARAMETER['Standard_Parallel_1',29.5],PARAMETER['Standard_Parallel_2',45.5],PARAMETER['latitude_of_origin',23.0],UNIT['Meter',1.0]]"
         printMsg('Re-projecting filtered roads to CONUS...')
         arcpy.Project_management(roads_filt, roads_prj, cs, "", "", "PRESERVE_SHAPE")
         printMsg('Roads re-projected.')
      
      except:
         printMsg('Processing failed or incomplete for GEOID %s'%geoid)
         failList.append(geoid)
         tbackInLoop()
      
      finally:
         for fc in [roads_filt]:
            arcpy.Delete_management(fc)

   printMsg('Finished processing shapefiles.')
   if len(failList) > 0:
      printMsg('Errors were encountered. The shapefiles for the following GEOIDs failed to process:')
      printMsg(failList)
   
def CreateRoadSurfaces(inRoadsGDB, inSurfGDB, widthOption):
   '''For all feature classes in the input geodatabase, assigns buffer widths and creates road surfaces.
   Parameters:
   - inRoadsGDB: Geodatabase containing the roads feature classes. (The feature classes should have been generated by the FilterAndProject function, and the geodatabase should not contain any other data).
   - inSurfGDB: Geodatabase designated for storing output road surfaces. (This must already exist; it is not created on the fly. It should not contain any other data.)
   - widthOption: Specifies which codeblock to use, with options MIN, MAX, or MID
   '''
   
   # Parameter check
   if widthOption not in ['MIN', 'MAX', 'MID']:
      printMsg('The buffer width options are "MIN", "MAX", or "MID". Aborting.')
      return

   # Get list of feature classes to process
   arcpy.env.workspace = inRoadsGDB
   inRoads = arcpy.ListFeatureClasses()
   
   # Set up failure list
   failList = []
   
   # Set up codeblock and expression for buffer calculations
   expression = 'calculateBuffer(!MTFCC!, !RTTYP!, "%s")' %widthOption
   code_block = """def calculateBuffer(mtfcc, rttyp, wo):
      convFactor = 0.1524 # This converts feet to meters, then divides by 2 to get buffer width
      
      # Primary Roads
      if mtfcc == 'S1100':
         laneWidth = 24
         shoulderWidth = 24

      # Secondary Roads
      elif mtfcc == 'S1200':
         # U.S. and State Highways
         if rttyp in ('U', 'S'):
            # possible lane widths: 22, 24
            # possible shoulder widths: 8, 12, 16
            if wo == "MIN":
               laneWidth = 22
               shoulderWidth = 8
            elif wo == "MID":
               laneWidth = 23
               shoulderWidth = 12
            else:
               laneWidth = 24
               shoulderWidth = 16
         
         # Other road types (e.g., county highways)
         else:
            # possible lane widths: 20, 22, 24
            # possible shoulder widths: 4, 10, 12, 16
            if wo == "MIN":
               laneWidth = 20
               shoulderWidth = 4
            elif wo =="MID":
               laneWidth = 22
               shoulderWidth = 10
            else:
               laneWidth = 24
               shoulderWidth = 16
      
      # Local roads
      else: 
         # possible lane widths: 18, 20, 22, 24
         # possible shoulderwidths: 4, 10, 12, 16
         if wo == "MIN":
            laneWidth = 18
            shoulderWidth = 4
         elif wo == "MID":
            laneWidth = 21
            shoulderWidth = 10
         else:
            laneWidth = 24
            shoulderWidth = 16

      roadWidth_FT = laneWidth + shoulderWidth
      buff_M = roadWidth_FT * convFactor
      return buff_M"""

   # For each feature class in list:
   for roads in inRoads:
      try:
         name = os.path.basename(roads)
         printMsg('Feature class name is %s'%name)
         geoid = name[-5:]
         roads_surf = inSurfGDB + os.sep + "roads_surf_%s_%s" %(widthOption, geoid)
         
         printMsg('Working on GEOID %s...'%geoid)
         
         # Assign buffer width based on MTFCC and RTTYP fields
         printMsg('Calculating buffer widths. This could take awhile...')
         if widthOption == "MIN":
            buffFld = "BUFF_M_MIN"
         elif widthOption == "MID":
            buffFld = "BUFF_M_MID"
         else:
            buffFld = "BUFF_M_MAX"
         
         arcpy.AddField_management (roads, buffFld, "DOUBLE")
         arcpy.CalculateField_management (roads, buffFld, expression, 'PYTHON', code_block)
         
         # Apply buffers
         printMsg('Creating road surfaces. This could take awhile...')
         arcpy.Buffer_analysis(roads, roads_surf, buffFld, "FULL", "FLAT", "NONE", "", "PLANAR")
      except:
         printMsg('Processing failed or incomplete for GEOID %s'%geoid)
         failList.append(geoid)
         tbackInLoop()
      
   printMsg('Finished making road surfaces.')
   if len(failList) > 0:
      printMsg('Errors were encountered. The feature classes for the following GEOIDs failed to process:')
      printMsg(failList)

def MergeFeatsInGDB(inGDB, outFC):
   '''Merges all feature classes within geodatabase into a single feature class.
   Parameters:
   - inGDB: Geodatabase containing the feature classes to merge. All feature classes are assumed to be of the same type with the same data structure.
   - outFC: Output feature class resulting from the merge.
   '''

   # Get list of feature classes to merge
   printMsg('Collecting feature classes to merge...')
   arcpy.env.workspace = inGDB
   inFC = arcpy.ListFeatureClasses()   

   # Run the merge
   printMsg('Merging %s feature classes...'%str(len(inFC)))
   arcpy.Merge_management (inFC, outFC)
   printMsg('Finished merging.')
      
def main():
   # Set up variables here
   inDir = r'H:\Enviva\Roads\Zips\unzip'
   inRoadsGDB = r'H:\Enviva\Roads\Outputs\projectedRoads.gdb'
   midSurfGDB = r'H:\Enviva\Roads\Outputs\roadSurfaces_mid.gdb'
   midSurfRoads = r'H:\Enviva\Roads\Outputs\roadSurfaces_merged.gdb\roadSurf_mid'
   
   # Set up function runs here
   FilterAndProject(inDir, inRoadsGDB)
   CreateRoadSurfaces(inRoadsGDB, midSurfRoads, "MID")
   MergeFeatsInGDB(midSurfGDB, midSurfRoads)
   
if __name__ == '__main__':
   main()
